<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Pair ‚Äî Matching</title>

  <style>
    html,body{margin:0;padding:0;background:transparent;overflow:hidden;height:100%}
    #root{position:absolute; inset:0; pointer-events:auto}

    /* HUD */
    #hud{
      position:absolute;
      left:16px; top:16px;
      display:flex; gap:10px; flex-wrap:wrap;
      z-index:20;
    }
    .btn{
      border:none;
      border-radius:999px;
      padding:10px 14px;
      font-weight:900;
      cursor:pointer;
      background: rgba(255,255,255,.90);
      color:#111;
      box-shadow: 0 10px 24px rgba(0,0,0,.22);
      font-size:13px;
    }
    .btn:active{transform: translateY(1px)}
    .pill{
      border-radius:999px;
      padding:10px 14px;
      font-weight:900;
      background: rgba(0,0,0,.35);
      color:#fff;
      border:1px solid rgba(255,255,255,.14);
      box-shadow: 0 10px 24px rgba(0,0,0,.22);
      font-size:13px;
    }

    /* SVG overlay */
    svg{position:absolute; inset:0; width:100%; height:100%; overflow:visible; z-index:5}

    /* Anchors (–≤ –∏–≥—Ä–µ –º–æ–∂–Ω–æ –ø–æ—á—Ç–∏ –Ω–µ–≤–∏–¥–∏–º—ã–º–∏, –Ω–æ –∫–ª–∏–∫–∞–±–µ–ª—å–Ω—ã–º–∏) */
    .anchor{
      position:absolute;
      width:22px; height:22px;
      border-radius:999px;
      transform: translate(-50%,-50%);
      background: rgba(255,255,255,.14);
      border:2px solid rgba(255,255,255,.55);
      box-shadow: 0 0 18px rgba(0,240,255,.18);
      cursor:pointer;
      z-index:10;
      user-select:none;
    }
    .anchor.left{border-color: rgba(0,240,255,.75)}
    .anchor.right{border-color: rgba(255,215,0,.75)}
    .anchor.active{outline: 3px solid rgba(255,255,255,.18)}

    /* —Ñ–∏–Ω–∞–ª—å–Ω—ã–π —Ñ–∏–¥–±–µ–∫ */
    #final{
      position:absolute; inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      z-index:50;
      pointer-events:auto;
    }
    #final .box{
      max-width:min(720px, 86vw);
      background: rgba(0,0,0,.62);
      border:1px solid rgba(255,255,255,.18);
      border-radius: 18px;
      box-shadow: 0 20px 40px rgba(0,0,0,.35);
      padding:16px;
      display:flex;
      flex-direction:column;
      gap:12px;
      align-items:center;
      text-align:center;
      color:#fff;
    }
    #final .text{
      font-weight:900;
      font-size: clamp(18px, 3.1vw, 30px);
      line-height:1.1;
    }
    #final img{
      max-width: min(420px, 70vw);
      max-height: 60vh;
      border-radius: 14px;
      display:block;
      filter: drop-shadow(0 16px 28px rgba(0,0,0,.35));
    }

    /* –∞–Ω–∏–º–∞—Ü–∏–∏ */
    @keyframes draw {
      from { stroke-dashoffset: var(--len); }
      to   { stroke-dashoffset: 0; }
    }
    @keyframes shake {
      0%,100%{ transform: translateX(0); }
      20%{ transform: translateX(-6px); }
      40%{ transform: translateX(6px); }
      60%{ transform: translateX(-4px); }
      80%{ transform: translateX(4px); }
    }
  </style>
</head>

<body>
<div id="root">
  <div id="hud">
    <button class="btn" id="checkBtn">–ü—Ä–æ–≤–µ—Ä–∏—Ç—å</button>
    <button class="btn" id="resetBtn">–°–±—Ä–æ—Å</button>
    <div class="pill" id="scorePill">0 / 0</div>
  </div>

  <svg id="svg" aria-hidden="true"></svg>

  <div id="final">
    <div class="box">
      <div class="text" id="finalText">üéâ –ú–æ–ª–æ–¥–µ—Ü!</div>
      <img id="finalImg" alt="" style="display:none"/>
    </div>
  </div>
</div>

<script>
(async function(){
  const root = document.getElementById('root');
  const svg  = document.getElementById('svg');

  const qp = new URLSearchParams(location.search);
  const cfgId = qp.get('id');

  const JSON_BASE = "https://nikashum93.github.io/texts/data/";
  if(!cfgId){ console.warn('–ù–µ—Ç id'); return; }

  let cfg;
  try{
    const res = await fetch(`${JSON_BASE}${encodeURIComponent(cfgId)}.json?v=${Date.now()}`, {cache:'no-store'});
    cfg = await res.json();
  }catch(e){
    console.warn('JSON load failed', e);
    return;
  }

  const anchors = cfg.anchors || {};
  const pairs = cfg.pairs || [];
  const settings = cfg.settings || {};
  const style = cfg.style || {};
  const feedback = cfg.feedback || { enabled:true, mode:'both', text:'', image:'' };

  const connectMode = settings.connectMode || 'drag';       // drag|click
  const checkMode = settings.checkMode || 'button';         // button|instant
  const oneToOne = settings.oneToOne !== false;
  const wrongBehavior = settings.wrongBehavior || 'mark';    // mark|shakeRemove
  const showButtons = settings.showButtons !== false;

  const ropeWidth = style.ropeWidth || 8;
  const curve = (typeof style.curve === 'number') ? style.curve : 0.35;
  const ropeColor = style.ropeColor || '#66ccff';
  const correctColor = style.correctColor || '#5cff9d';
  const wrongColor = style.wrongColor || '#ff4d4d';
  const glow = style.glow !== false;
  const drawAnim = style.drawAnim !== false;

  // UI
  const checkBtn = document.getElementById('checkBtn');
  const resetBtn = document.getElementById('resetBtn');
  const scorePill = document.getElementById('scorePill');

  document.getElementById('hud').style.display = showButtons ? 'flex' : 'none';
  if(checkMode === 'instant'){ checkBtn.style.display = 'none'; }

  // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ –ø–∞—Ä—ã –≤ Set (L->R)
  const correctSet = new Set(pairs.map(p => `${p.from}=>${p.to}`));

  // –°–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä–æ–∫–∞: linkMap —Ö—Ä–∞–Ω–∏—Ç Lx -> Ry
  const linkMap = new Map();   // leftId -> rightId
  const pathMap = new Map();   // key "L=>R" -> {shadow, main, c1, c2}

  // build anchors DOM
  const anchorEls = {};
  function stageRect(){ return root.getBoundingClientRect(); }
  function toPx(a){
    const r = stageRect();
    return { x: (a.x||0)*r.width, y: (a.y||0)*r.height };
  }

  Object.keys(anchors).forEach(id=>{
    const a = anchors[id];
    const el = document.createElement('div');
    el.className = 'anchor ' + (a.side || '');
    el.dataset.id = id;
    root.appendChild(el);
    anchorEls[id] = el;
  });

  function layoutAnchors(){
    Object.keys(anchors).forEach(id=>{
      const a = anchors[id];
      const el = anchorEls[id];
      if(!el) return;
      const p = toPx(a);
      el.style.left = p.x + 'px';
      el.style.top  = p.y + 'px';
    });
    redrawAll();
  }
  window.addEventListener('resize', layoutAnchors);
  layoutAnchors();

  // SVG helpers
  function makePath(d, stroke, w, alpha){
    const p = document.createElementNS('http://www.w3.org/2000/svg','path');
    p.setAttribute('d', d);
    p.setAttribute('fill','none');
    p.setAttribute('stroke', stroke);
    p.setAttribute('stroke-width', w);
    p.setAttribute('stroke-linecap','round');
    p.setAttribute('stroke-linejoin','round');
    if(typeof alpha === 'number') p.setAttribute('opacity', alpha);
    if(glow){
      p.style.filter = 'drop-shadow(0 0 10px rgba(255,255,255,.18))';
    }
    return p;
  }
  function makeCircle(x,y,r,fill,alpha){
    const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
    c.setAttribute('cx', x);
    c.setAttribute('cy', y);
    c.setAttribute('r', r);
    c.setAttribute('fill', fill);
    if(typeof alpha === 'number') c.setAttribute('opacity', alpha);
    if(glow){
      c.style.filter = 'drop-shadow(0 0 10px rgba(255,255,255,.18))';
    }
    return c;
  }

  function curvePath(A,B){
    const dx = Math.max(80, Math.abs(B.x - A.x) * curve);
    return `M ${A.x} ${A.y} C ${A.x + dx} ${A.y}, ${B.x - dx} ${B.y}, ${B.x} ${B.y}`;
  }

  function removeLink(leftId){
    const rightId = linkMap.get(leftId);
    if(!rightId) return;
    const key = `${leftId}=>${rightId}`;
    const pack = pathMap.get(key);
    if(pack){
      pack.shadow.remove();
      pack.main.remove();
      pack.c1.remove();
      pack.c2.remove();
      pathMap.delete(key);
    }
    linkMap.delete(leftId);
  }

  function removeAnyUsing(id){
    // –µ—Å–ª–∏ oneToOne ‚Äî –≤—ã–∫–∏–¥—ã–≤–∞–µ–º —Å–≤—è–∑–∏, –≥–¥–µ —É—á–∞—Å—Ç–≤—É–µ—Ç id
    if(!oneToOne) return;
    // –µ—Å–ª–∏ id ‚Äî –ª–µ–≤—ã–π: removeLink(id)
    if(anchors[id]?.side === 'left'){
      removeLink(id);
      // –∞ –µ—Å–ª–∏ —ç—Ç–æ—Ç id –±—ã–ª —Å–ø—Ä–∞–≤–∞ ‚Äî —É–¥–∞–ª–∏–º —É —Ç–æ–≥–æ, –∫—Ç–æ –Ω–∞ –Ω–µ–≥–æ —É–∫–∞–∑—ã–≤–∞–µ—Ç
      for(const [l,r] of linkMap.entries()){
        if(r === id){ removeLink(l); }
      }
    }else{
      // id —Å–ø—Ä–∞–≤–∞
      for(const [l,r] of linkMap.entries()){
        if(r === id){ removeLink(l); }
      }
    }
  }

  function link(leftId, rightId, paintColor = ropeColor){
    if(!anchors[leftId] || !anchors[rightId]) return;
    if(anchors[leftId].side !== 'left' || anchors[rightId].side !== 'right') return;

    if(oneToOne){
      removeAnyUsing(leftId);
      removeAnyUsing(rightId);
    }

    linkMap.set(leftId, rightId);

    const key = `${leftId}=>${rightId}`;
    // —É–¥–∞–ª–∏–º —Å—Ç–∞—Ä—ã–π (–µ—Å–ª–∏ –±—ã–ª)
    if(pathMap.has(key)){
      const old = pathMap.get(key);
      old.shadow.remove(); old.main.remove(); old.c1.remove(); old.c2.remove();
      pathMap.delete(key);
    }

    const A = toPx(anchors[leftId]);
    const B = toPx(anchors[rightId]);
    const d = curvePath(A,B);

    // shadow + main
    const shadow = makePath(d, 'rgba(0,0,0,.35)', ropeWidth+6, 1);
    const main = makePath(d, paintColor, ropeWidth, 1);

    // end caps
    const c1 = makeCircle(A.x, A.y, Math.max(4, ropeWidth*0.55), paintColor, 0.95);
    const c2 = makeCircle(B.x, B.y, Math.max(4, ropeWidth*0.55), paintColor, 0.95);

    svg.appendChild(shadow);
    svg.appendChild(main);
    svg.appendChild(c1);
    svg.appendChild(c2);

    // draw anim
    if(drawAnim){
      const len = main.getTotalLength();
      main.style.strokeDasharray = String(len);
      main.style.strokeDashoffset = String(len);
      main.style.setProperty('--len', len);
      main.style.animation = 'draw .35s ease-out forwards';
    }

    pathMap.set(key, {shadow, main, c1, c2, leftId, rightId});
    updateScorePill();
    if(checkMode === 'instant') instantValidateLast(leftId, rightId);
  }

  function redrawAll(){
    // –ø–µ—Ä–µ—Å–æ–∑–¥–∞—Ç—å svg –¥–ª—è –≤—Å–µ—Ö —Ç–µ–∫—É—â–∏—Ö —Å–≤—è–∑–µ–π
    svg.innerHTML = '';
    const current = Array.from(linkMap.entries());
    pathMap.clear();
    for(const [l,r] of current){
      link(l,r, ropeColor);
    }
  }

  function updateScorePill(){
    scorePill.textContent = `${countCorrect()} / ${pairs.length}`;
  }

  function countCorrect(){
    let ok = 0;
    for(const [l,r] of linkMap.entries()){
      if(correctSet.has(`${l}=>${r}`)) ok++;
    }
    return ok;
  }

  function allCorrect(){
    return pairs.length > 0 && countCorrect() === pairs.length && linkMap.size === pairs.length;
  }

  function paintLink(leftId, rightId, color){
    const key = `${leftId}=>${rightId}`;
    const pack = pathMap.get(key);
    if(!pack) return;
    pack.main.setAttribute('stroke', color);
    pack.c1.setAttribute('fill', color);
    pack.c2.setAttribute('fill', color);
  }

  function wrongEffect(leftId, rightId){
    const key = `${leftId}=>${rightId}`;
    const pack = pathMap.get(key);
    if(!pack) return;

    if(wrongBehavior === 'shakeRemove'){
      pack.main.style.animation = 'shake .35s ease';
      pack.shadow.style.animation = 'shake .35s ease';
      setTimeout(()=>{ removeLink(leftId); updateScorePill(); }, 280);
    }else{
      paintLink(leftId, rightId, wrongColor);
    }
  }

  function instantValidateLast(leftId, rightId){
    const good = correctSet.has(`${leftId}=>${rightId}`);
    if(good){
      paintLink(leftId, rightId, correctColor);
      if(allCorrect()) showFinal();
    }else{
      wrongEffect(leftId, rightId);
    }
  }

  function checkAll(){
    // –ø–æ–¥—Å–≤–µ—Ç–∫–∞ –≤—Å–µ—Ö —Å–≤—è–∑–µ–π
    for(const [l,r] of linkMap.entries()){
      const good = correctSet.has(`${l}=>${r}`);
      paintLink(l,r, good ? correctColor : wrongColor);
      if(!good && wrongBehavior === 'shakeRemove'){
        wrongEffect(l,r);
      }
    }
    setTimeout(()=>{
      updateScorePill();
      if(allCorrect()) showFinal();
    }, 320);
  }

  function resetAll(){
    linkMap.clear();
    pathMap.forEach(p=>{ p.shadow.remove(); p.main.remove(); p.c1.remove(); p.c2.remove(); });
    pathMap.clear();
    svg.innerHTML = '';
    activeStart = null;
    Object.values(anchorEls).forEach(el=>el.classList.remove('active'));
    updateScorePill();
    hideFinal();
  }

  checkBtn.addEventListener('click', checkAll);
  resetBtn.addEventListener('click', resetAll);

  // ---------- connect interaction ----------
  let activeStart = null;     // id —Ç–æ—á–∫–∏ —Å—Ç–∞—Ä—Ç–∞
  let dragging = false;
  let tempPath = null;

  function anchorAtPoint(clientX, clientY){
    // –Ω–∞–π–¥—ë–º anchor –ø–æ–¥ –∫—É—Ä—Å–æ—Ä–æ–º
    const el = document.elementFromPoint(clientX, clientY);
    if(!el) return null;
    if(el.classList && el.classList.contains('anchor')) return el.dataset.id;
    return null;
  }

  function startFrom(id){
    activeStart = id;
    Object.values(anchorEls).forEach(el=>el.classList.remove('active'));
    anchorEls[id]?.classList.add('active');
  }

  function finishTo(id){
    const a = anchors[activeStart];
    const b = anchors[id];
    if(!a || !b) return;

    // –Ω–æ—Ä–º–∞–ª–∏–∑—É–µ–º: —Ç–æ–ª—å–∫–æ left -> right
    let leftId = null, rightId = null;
    if(a.side === 'left' && b.side === 'right'){ leftId = activeStart; rightId = id; }
    if(a.side === 'right' && b.side === 'left'){ leftId = id; rightId = activeStart; }

    if(!leftId || !rightId){
      // –æ–¥–∏–Ω–∞–∫–æ–≤–∞—è —Å—Ç–æ—Ä–æ–Ω–∞ ‚Äî –∏–≥–Ω–æ—Ä
      return;
    }

    link(leftId, rightId, ropeColor);

    anchorEls[activeStart]?.classList.remove('active');
    activeStart = null;
  }

  function tempLine(fromId, clientX, clientY){
    // –≤—Ä–µ–º–µ–Ω–Ω–∞—è –ª–∏–Ω–∏—è –≤–æ –≤—Ä–µ–º—è drag
    const r = stageRect();
    const A = toPx(anchors[fromId]);
    const B = { x: clientX - r.left, y: clientY - r.top };
    const d = curvePath(A,B);

    if(!tempPath){
      tempPath = makePath(d, ropeColor, ropeWidth, 0.75);
      svg.appendChild(tempPath);
    }else{
      tempPath.setAttribute('d', d);
    }
  }

  function clearTemp(){
    if(tempPath){ tempPath.remove(); tempPath = null; }
  }

  Object.values(anchorEls).forEach(el=>{
    const id = el.dataset.id;

    if(connectMode === 'click'){
      el.addEventListener('click', (e)=>{
        e.stopPropagation();
        if(!activeStart){ startFrom(id); return; }
        if(activeStart === id){
          anchorEls[id]?.classList.remove('active');
          activeStart = null;
          return;
        }
        finishTo(id);
      });
    }else{
      // drag
      el.addEventListener('pointerdown', (e)=>{
        e.stopPropagation();
        dragging = true;
        el.setPointerCapture(e.pointerId);
        startFrom(id);
        tempLine(id, e.clientX, e.clientY);
      });
    }
  });

  window.addEventListener('pointermove', (e)=>{
    if(!dragging || !activeStart) return;
    tempLine(activeStart, e.clientX, e.clientY);
  });

  window.addEventListener('pointerup', (e)=>{
    if(!dragging) return;
    dragging = false;
    clearTemp();

    const targetId = anchorAtPoint(e.clientX, e.clientY);
    if(targetId && activeStart && targetId !== activeStart){
      finishTo(targetId);
    }else{
      // –Ω–µ –ø–æ–ø–∞–ª–∏ ‚Äî –ø—Ä–æ—Å—Ç–æ —Å–±—Ä–æ—Å
      anchorEls[activeStart]?.classList.remove('active');
      activeStart = null;
    }
  });

  // ---------- final feedback ----------
  const final = document.getElementById('final');
  const finalTextEl = document.getElementById('finalText');
  const finalImgEl = document.getElementById('finalImg');

  function showFinal(){
    if(!feedback.enabled) return;

    const mode = feedback.mode || 'both';
    finalTextEl.textContent = feedback.text || 'üéâ –ú–æ–ª–æ–¥–µ—Ü!';
    finalImgEl.style.display = 'none';
    finalTextEl.style.display = 'block';

    if(mode === 'image'){
      finalTextEl.style.display = 'none';
    }
    if(mode === 'text'){
      finalImgEl.style.display = 'none';
    }
    if((mode === 'both' || mode === 'image') && feedback.image){
      finalImgEl.src = feedback.image;
      finalImgEl.style.display = 'block';
    }

    final.style.display = 'flex';
  }

  function hideFinal(){
    final.style.display = 'none';
  }

  // —Å—Ç–∞—Ä—Ç–æ–≤—ã–π —Å—á—ë—Ç
  updateScorePill();

})();
</script>
</body>
</html>
