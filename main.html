<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Pair ‚Äî Game</title>
  <style>
    html,body{height:100%}
    body{
      margin:0;
      background: transparent;
      overflow:hidden;
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    }
    #root{
      position:fixed; inset:0;
      width:100vw; height:100vh;
      pointer-events:auto;
    }
    #svg{
      position:absolute; inset:0;
      width:100%; height:100%;
      pointer-events:none;
    }
    .anchor{
      position:absolute;
      width:24px; height:24px;
      border-radius:999px;
      transform: translate(-50%,-50%);
      display:flex; align-items:center; justify-content:center;
      font-size:11px; font-weight:900;
      cursor:pointer;
      user-select:none;
      touch-action:none;
    }
    .anchor.left{
      border:2px solid rgba(0,240,255,.75);
      background: rgba(0,0,0,.35);
      box-shadow:0 0 18px rgba(0,240,255,.22);
    }
    .anchor.right{
      border:2px solid rgba(255,215,0,.80);
      background: rgba(0,0,0,.35);
      box-shadow:0 0 18px rgba(255,215,0,.22);
    }

    /* HUD */
    #hud{
      position:absolute; top:18px; left:18px;
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
      z-index:10;
    }
    .pill{
      padding:10px 14px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(0,0,0,.45);
      color:#fff;
      font-weight:900;
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
    }
    .btn{
      padding:10px 14px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.10);
      color:#fff;
      font-weight:900;
      cursor:pointer;
    }
    .btn:hover{background: rgba(255,255,255,.14)}

    /* final */
    #finalOverlay{
      position:absolute; inset:0;
      background: rgba(0,0,0,.55);
      display:none;
      align-items:center; justify-content:center;
      z-index:50;
      padding:24px;
    }
    #finalCard{
      max-width:min(720px, 92vw);
      background: rgba(0,0,0,.72);
      border:2px solid rgba(255,255,255,.18);
      border-radius:20px;
      color:#fff;
      padding:18px 18px 16px;
      text-align:center;
      box-shadow: 0 18px 50px rgba(0,0,0,.45);
      animation: pop .35s ease-out;
    }
    #finalCard img{
      display:block;
      width:min(320px, 70vw);
      margin:12px auto 0;
      filter: drop-shadow(0 16px 28px rgba(0,0,0,.35));
    }
    @keyframes pop{
      from{opacity:0; transform: scale(.96)}
      to{opacity:1; transform: scale(1)}
    }
  </style>
</head>
<body>
<div id="root">
  <svg id="svg" viewBox="0 0 1920 1080" preserveAspectRatio="none">
    <defs>
      <pattern id="ropeTex" width="10" height="10" patternUnits="userSpaceOnUse" patternTransform="rotate(18)">
        <rect width="10" height="10" fill="#caa15a"></rect>
        <path d="M0 2 H10" stroke="#b38b45" stroke-width="2" opacity="0.75"></path>
        <path d="M0 6 H10" stroke="#d8b46a" stroke-width="2" opacity="0.55"></path>
        <path d="M0 9 H10" stroke="#9a7539" stroke-width="1" opacity="0.35"></path>
      </pattern>
      <filter id="ropeShadow" x="-30%" y="-30%" width="160%" height="160%">
        <feDropShadow dx="0" dy="6" stdDeviation="6" flood-color="#000" flood-opacity="0.35"/>
      </filter>
    </defs>
  </svg>

  <div id="hud">
    <div class="pill" id="scorePill">0 / 0</div>
    <button class="btn" id="btnCheck">–ü—Ä–æ–≤–µ—Ä–∏—Ç—å</button>
    <button class="btn" id="btnReset">–°–±—Ä–æ—Å</button>
  </div>

  <div id="finalOverlay">
    <div id="finalCard">
      <div id="finalText">üéâ –û—Ç–ª–∏—á–Ω–æ!</div>
      <img id="finalImg" alt="" style="display:none;">
    </div>
  </div>
</div>

<script>
(()=>{
  const root = document.getElementById('root');
  const svg = document.getElementById('svg');
  const urlParams = new URLSearchParams(location.search);

  // –∫–∞–∫ —É Utki: —á–∏—Ç–∞–µ–º JSON –ø–æ id –∏–∑ texts/data
  const JSON_BASE = "https://nikashum93.github.io/texts/data/";
  const cfgId = urlParams.get('id');

  let cfg = null;

  // runtime state
  const anchors = new Map(); // id -> {id,side,x,y,el}
  const correct = new Set(); // "L=>R"
  const linkMapL = new Map(); // leftId -> rightId
  const linkMapR = new Map(); // rightId -> leftId
  const ropeGroups = []; // svg g elements
  let dragging = null; // {leftId, tempG}

  const scorePill = document.getElementById('scorePill');
  const btnCheck = document.getElementById('btnCheck');
  const btnReset = document.getElementById('btnReset');

  const finalOverlay = document.getElementById('finalOverlay');
  const finalTextEl = document.getElementById('finalText');
  const finalImgEl = document.getElementById('finalImg');

  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
  function rect(){ return root.getBoundingClientRect(); }

  function ropeD(x1,y1,x2,y2,sag){
    const mx = (x1+x2)/2;
    const my = (y1+y2)/2 + sag;
    return `M ${x1} ${y1} Q ${mx} ${my} ${x2} ${y2}`;
  }

  function drawRope(x1,y1,x2,y2, good=null){
    const w = cfg?.style?.ropeWidth ?? 18;
    const sag = cfg?.style?.ropeSag ?? 70;

    const d = ropeD(x1,y1,x2,y2,sag);

    const g = document.createElementNS("http://www.w3.org/2000/svg","g");

    const sh = document.createElementNS("http://www.w3.org/2000/svg","path");
    sh.setAttribute("d", d);
    sh.setAttribute("fill","none");
    sh.setAttribute("stroke","#000");
    sh.setAttribute("stroke-width", w + 6);
    sh.setAttribute("stroke-linecap","round");
    sh.setAttribute("opacity","0.16");
    sh.setAttribute("filter","url(#ropeShadow)");

    const body = document.createElementNS("http://www.w3.org/2000/svg","path");
    body.setAttribute("d", d);
    body.setAttribute("fill","none");
    body.setAttribute("stroke","url(#ropeTex)");
    body.setAttribute("stroke-width", w);
    body.setAttribute("stroke-linecap","round");
    body.setAttribute("stroke-linejoin","round");

    const hl = document.createElementNS("http://www.w3.org/2000/svg","path");
    hl.setAttribute("d", d);
    hl.setAttribute("fill","none");
    hl.setAttribute("stroke","#fff");
    hl.setAttribute("stroke-width", Math.max(2, w*0.22));
    hl.setAttribute("stroke-linecap","round");
    hl.setAttribute("opacity","0.28");

    g.appendChild(sh);
    g.appendChild(body);
    g.appendChild(hl);

    if (good === true || good === false){
      const ov = document.createElementNS("http://www.w3.org/2000/svg","path");
      ov.setAttribute("d", d);
      ov.setAttribute("fill","none");
      ov.setAttribute("stroke", good ? "#00e676" : "#ff5252");
      ov.setAttribute("stroke-width", Math.max(3, w*0.35));
      ov.setAttribute("stroke-linecap","round");
      ov.setAttribute("opacity","0.75");
      g.appendChild(ov);
    }

    // animation draw
    const len = body.getTotalLength();
    [sh, body, hl].forEach(p=>{
      p.style.strokeDasharray = len;
      p.style.strokeDashoffset = len;
      p.style.transition = "stroke-dashoffset 380ms ease-out";
    });
    requestAnimationFrame(()=>{
      [sh, body, hl].forEach(p=>p.style.strokeDashoffset = "0");
    });

    svg.appendChild(g);
    ropeGroups.push(g);
    return g;
  }

  function clearRopes(){
    while(ropeGroups.length){
      const g = ropeGroups.pop();
      try{ g.remove(); }catch(_){}
    }
  }

  function placeAnchor(a){
    const el = document.createElement('div');
    el.className = 'anchor ' + a.side;
    el.textContent = a.side === 'left' ? 'L' : 'R';

    anchors.set(a.id, {...a, el});

    root.appendChild(el);

    el.addEventListener('pointerdown', (e)=>{
      e.preventDefault();
      e.stopPropagation();
      if(a.side !== 'left') return;

      // start drag connection from left
      dragging = { leftId: a.id, tempG: null };
      el.setPointerCapture(e.pointerId);
      updateTempRope(e.clientX, e.clientY);

      window.addEventListener('pointermove', onMove);
      window.addEventListener('pointerup', onUp);
      function onMove(ev){
        updateTempRope(ev.clientX, ev.clientY);
      }
      function onUp(ev){
        window.removeEventListener('pointermove', onMove);
        window.removeEventListener('pointerup', onUp);
        try{ el.releasePointerCapture(e.pointerId); }catch(_){}
        finishDrop(ev.clientX, ev.clientY);
      }
    });
  }

  function updateAnchorPositions(){
    const r = rect();
    for(const a of anchors.values()){
      a.el.style.left = (a.x * r.width) + 'px';
      a.el.style.top  = (a.y * r.height) + 'px';
    }
  }

  function toSvgXY(clientX, clientY){
    const r = rect();
    const nx = clamp((clientX - r.left)/r.width, 0, 1);
    const ny = clamp((clientY - r.top)/r.height, 0, 1);
    return { x: nx*1920, y: ny*1080 };
  }

  function getAnchorCenterSvg(id){
    const a = anchors.get(id);
    return { x: a.x*1920, y: a.y*1080 };
  }

  function updateTempRope(clientX, clientY){
    if(!dragging) return;
    const L = getAnchorCenterSvg(dragging.leftId);
    const P = toSvgXY(clientX, clientY);

    // redraw temp
    if(dragging.tempG) dragging.tempG.remove();
    dragging.tempG = drawRope(L.x, L.y, P.x, P.y, null);
    // make temp a bit transparent
    dragging.tempG.style.opacity = '0.65';
  }

  function findHitRight(clientX, clientY){
    const r = rect();
    const x = clientX - r.left;
    const y = clientY - r.top;

    for(const a of anchors.values()){
      if(a.side !== 'right') continue;
      const ax = a.x * r.width;
      const ay = a.y * r.height;
      const dx = ax - x, dy = ay - y;
      if(Math.hypot(dx,dy) < 26) return a.id;
    }
    return null;
  }

  function setLink(leftId, rightId){
    // overwrite if already linked
    const prevR = linkMapL.get(leftId);
    if(prevR){
      linkMapL.delete(leftId);
      linkMapR.delete(prevR);
    }
    const prevL = linkMapR.get(rightId);
    if(prevL){
      linkMapR.delete(rightId);
      linkMapL.delete(prevL);
    }
    linkMapL.set(leftId, rightId);
    linkMapR.set(rightId, leftId);

    redrawLinks();

    if(cfg.autoCheck && linkMapL.size === cfg.pairs.length){
      checkAll();
    } else {
      updateScore();
    }
  }

  function redrawLinks(goodMap=null){
    clearRopes();
    for(const [l,r] of linkMapL.entries()){
      const L = getAnchorCenterSvg(l);
      const R = getAnchorCenterSvg(r);
      const good = goodMap ? goodMap.get(`${l}=>${r}`) : null;
      drawRope(L.x, L.y, R.x, R.y, good);
    }
  }

  function finishDrop(clientX, clientY){
    if(!dragging) return;

    const hit = findHitRight(clientX, clientY);

    // remove temp
    try{ dragging.tempG?.remove(); }catch(_){}
    dragging = null;

    if(!hit) { updateScore(); return; }
    setLink(dragging?.leftId, hit);
  }

  function updateScore(){
    scorePill.textContent = `${linkMapL.size} / ${cfg.pairs.length}`;
  }

  function flash(text, bad=false){
    scorePill.textContent = text;
    scorePill.style.background = bad ? 'rgba(255,82,82,.30)' : 'rgba(0,230,118,.20)';
    setTimeout(()=>{
      scorePill.style.background = '';
      updateScore();
    }, 1100);
  }

  function checkAll(){
    const goodMap = new Map();
    let ok = 0;
    for(const [l,r] of linkMapL.entries()){
      const key = `${l}=>${r}`;
      const good = correct.has(key);
      goodMap.set(key, good);
      if(good) ok++;
    }
    redrawLinks(goodMap);

    if(ok === cfg.pairs.length){
      showFinal();
    } else {
      flash(`–ù–µ–≤–µ—Ä–Ω–æ: ${ok} –∏–∑ ${cfg.pairs.length}. –ü–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑`, true);
    }
  }

  function resetAll(){
    linkMapL.clear();
    linkMapR.clear();
    redrawLinks();
    updateScore();
  }

  function showFinal(){
    finalTextEl.textContent = cfg.feedback?.finalText || 'üéâ –û—Ç–ª–∏—á–Ω–æ!';
    const img = (cfg.feedback?.finalImage || '').trim();
    if(img){
      finalImgEl.src = img;
      finalImgEl.style.display = 'block';
    } else {
      finalImgEl.style.display = 'none';
    }
    finalOverlay.style.display = 'flex';
    finalOverlay.addEventListener('click', ()=>finalOverlay.style.display='none', {once:true});
  }

  btnCheck.addEventListener('click', checkAll);
  btnReset.addEventListener('click', resetAll);

  async function init(){
    if(!cfgId){
      scorePill.textContent = '–ù–µ—Ç id';
      return;
    }

    try{
      const res = await fetch(`${JSON_BASE}${encodeURIComponent(cfgId)}.json?v=${Date.now()}`, { cache:'no-store' });
      cfg = await res.json();

      // build correct set
      (cfg.pairs||[]).forEach(p=>correct.add(`${p.leftId}=>${p.rightId}`));

      // anchors
      (cfg.anchors||[]).forEach(a=>placeAnchor(a));

      updateAnchorPositions();
      updateScore();

      window.addEventListener('resize', ()=>{
        updateAnchorPositions();
        redrawLinks();
      });

    }catch(e){
      scorePill.textContent = 'JSON –Ω–µ –∑–∞–≥—Ä—É–∑–∏–ª—Å—è';
      console.warn(e);
    }
  }

  init();
})();
</script>
</body>
</html>
